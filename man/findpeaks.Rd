% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/findpeaks.R
\name{findpeaks}
\alias{findpeaks}
\title{Find local maxima}
\usage{
findpeaks(data, minh = .Machine$double.eps, mind = 1, minw = 1,
  maxw = Inf, ds = FALSE)
}
\arguments{
\item{data}{The input signal vector.}

\item{minh}{Minimum peak height (non-negative scalar). Only peaks that exceed this value will be returned.
For data taking positive and negative values use the option \code{ds}.
Default: machine precision (.Machine$double.eps).}

\item{mind}{Minimum separation between peaks (positive integer). Peaks separated by less than this distance are considered
a single peak. This distance is also used to fit a second order polynomial to the peaks to estimate their width,
(see \code{details}, therefore it acts as a smoothing parameter. Default value 1.}

\item{minw}{Minimum width of peaks (positive integer). Default value 1.}

\item{maxw}{Maximum width of peaks (positive integer). Default value \code{Inf}.}

\item{ds}{Double-sided. Tells the function that data takes positive and negative values. The base-line for the peaks
is taken as the mean value of the function. This is equivalent as passing the absolute value of the data
after removing the mean.}
}
\value{
When called with \code{minw = 0} and \code{maxw = Inf}, this function returns a \code{\link{list}} containing
        two values:
  \describe{
    \item{\code{$pks}: }{array containing the value of \code{data} at the peaks}
    \item{\code{$idx}: }{array containing the peak indices}
  }
  When called with either \code{minw > 0} or \code{maxw < Inf}, then the returned \code{\link{list}} contains these additional
  variables:
  \describe{
    \item{\code{$parabol}: }{a \code{\link{list}} containing additional information about the parabol fitted to the peak.
    The \code{\link{list}} \code{$pp} contains the coefficients of the 2nd degree polynomial (\code{a}, \code{b}, and \code{b2}),
    and \code{$x} the extrema of the interval where it was fitted (\code{$from}, \code{to}).}
    \item{\code{$height}:}{The estimated height of the returned peaks (in units of \code{data}).}
    \item{\code{$baseline}: }{The height at which the roots of the returned peaks were calculated (in units of \code{data}).}
    \item{\code{$roots}: }{The abscissa values (in index units) at which the parabola fitted to each of the returned peaks
      realizes its width.}
  }
}
\description{
Find local maxima (peaks) in an input signal vector.
}
\details{
This function searches for peaks in a signal vector. Peaks of a positive array of data are defined as local maxima.
For double-sided data, they are maxima of the positive part and minima of the negative part. The function provides
various options to search for peaks in noisy data, such specifying a minimum peak height (\code{minh}), a minimum distance
between peaks (\code{mind}), and a minimum or maximum width of the peaks (\code{minw} and \code{maxw}).\cr\cr
The width of the peaks is estimated using a parabola fitted to the neighborhood of each peak. The width is caulculated
with the formula \eqn{a * (width - x0)^2 = 1}, where \eqn{a} is the the concavity of the parabola and \eqn{x0} its vertex.
The neighborhood size is equal to the value of \code{mind}.
}
\examples{
# Example 1: Finding the peaks of smooth data is not a big deal

t <- 2*pi*seq(0,1,length=1024)
y <- sin(3.14*t) + 0.5*cos(6.09*t) + 0.1*sin(10.11*t+1/6) + 0.1*sin(15.3*t+1/3)

data1 <- abs(y) # Positive values
peaks1 <- findpeaks(data1)

data2 <- y # Double-sided
peaks2 <- findpeaks(data2, ds=TRUE)
peaks3 <- findpeaks (data2, ds=TRUE, minh=0.5)

\dontrun{
  op <- par(mfrow=c(1,2))
  plot(t,data1,type="l", xlab="", ylab="")
  points (t[peaks1$idx],peaks1$pks,col="red", pch=1)
  plot(t,data2,type="l", xlab="", ylab="")
  points (t[peaks2$idx],peaks2$pks,col="red", pch=1)
  points (t[peaks3$idx],peaks3$pks,col="red", pch=4)
  legend ("topleft", '0: >2*sd, x: >0.5', bty="n", text.col="red")
  par (op)}

# Example 2: Noisy data may need tuning of the parameters. In this example,
# "mind" is used as a smoother of the peaks.

t <- 2*pi*seq(0,1,length=1024)
y <- sin(3.14*t) + 0.5*cos(6.09*t) + 0.1*sin(10.11*t+1/6) + 0.1*sin(15.3*t+1/3)
data <- abs(y + 0.1*rnorm(length(y),1)); # Positive values + noise
peaks1 <- findpeaks(data, minh=1)
dt <- t[2]-t[1]
peaks2 <- findpeaks(data, minh=1, mind=round(0.5/dt))

\dontrun{
  op <- par(mfrow=c(1,2))
  plot(t, data, type="l", xlab="", ylab="")
  points (t[peaks1$idx],peaks1$pks,col="red", pch=1)
  plot(t, data, type="l", xlab="", ylab="")
  points (t[peaks2$idx],peaks2$pks,col="red", pch=1)
  par (op)}

}
\references{
\href{https://octave.sourceforge.io/signal/}{Octave Signal package}
}
\author{
Geert van Boxtel
}
